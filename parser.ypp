%{
    #include "Utilities.hpp"
    #include "RulesTypes.hpp"
    #include "hw3_output.hpp"
%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token AUTO
%token ID
%token NUM
%token STRING
%token RETURN
%token TRUE
%token FALSE
%token IF
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token WHILE

%left   ASSIGN
%left   OR
%left   AND
%left   RELOP_EQUAL
%left   RELOP_GLT
%left   BINOP_ADD
%left   BINOP_MUL
%right  NOT
%left   LBRACE
%left   RBRACE
%left   LPAREN
%left   RPAREN
%nonassoc ELSE

%%
//rules
Program:    {openScope();
             addPrintFunctions();}
            Funcs
;

Funcs:      /*epsilon*/
            |FuncDecl Funcs
;

FuncDecl:   RetType ID LPAREN Formals RPAREN  {addFuncNewEntry($2->getId(),$1->getType(),$4->getVecArgsType());}
                                      LBRACE  {openScope();///MAYBE WE NEED TO BE ABLE TO OPEN SCOPE IN SIZE OF 50+SIZE OF ARGS
                                               addFuncArgsToTable($4->getVecArgsType(),$4->getVecArgsID());} /*add func args as neg entries*/
            Statements {closeScope();}
            RBRACE
;

RetType:    Type                            {$$ = new RetTypeClass($1->getType());}
            |VOID                           {$$ = new RetTypeClass("VOID"); }
;

Formals:	 /*epsilon*/                    {$$ = new FormalsClass();}
			|FormalsList                    {$$ = new FormalsClass($1->getVecArgsType(),$1->getVecArgsID());}
;

FormalsList: FormalDecl                     {$$ = new FormalsListClass();
                                             $$->addNewArg($1->getArgType(),$1->getArgID());}
			|FormalDecl COMMA FormalsList   {$$ = new FormalsListClass($3->getVecArgsType(),$3->getVecArgsID());
			                                 $$->addNewArg($1->getArgType(),$1->getArgID());}
;

FormalDecl:	Type ID                         {$$ = new FormalDeclClass($1->getType(),$2->getId()); }
;

Statements:	Statement               {$$ = new StatementClass();}
			|Statements Statement   {$$ = new StatementsClass($2->getNextlist()}
;

Statement:	Type ID SC              {addVarNewEntry($2->getId(), $1->getType());
                                    $$ = new StatementClass(STATEMENT_ID)}
			|Type ID ASSIGN Exp SC  {checkIfAssignValidByType($1->getType(), $4->getType());
			                        addVarNewEntry($2->getId(), $1->getType(), $4->getValue());
			                        $$ = new StatementClass(STATEMENT_TYPE_ID_ASS_EXP)}
			|AUTO ID ASSIGN Exp SC 	{checkIfAutoAssignValid($4->getType());
			                        addVarNewEntry($2->getId(),$4->getType(), $4->getValue());
			                        $$ = new StatementClass(STATEMENT_AUTO_ID_ASS_EXP)}
			|ID ASSIGN Exp SC     	{checkIfAssignValidByType(getIdVarType($1->getId()), $3->getType());
			                        $$ = new StatementClass(STATEMENT_ID_ASS_EXP);}
			|Call SC                {$$ = new StatementClass(STATMENT_CALL);}
			|RETURN SC				{checkReturnType("VOID");
			                        $$ = new StatementClass(STATEMENT_RET);}
			|RETURN Exp SC			{checkReturnType($2->getType());
			                        $$ = new StatementClass(STATEMENT_RET_EXP);}
			|BREAK SC				{checkIfBreakValid();
			                        $$ = new StatementClass(STATEMENT_BR);}
			|CONTINUE SC			{checkIfContinueValid();
			                        $$ = new StatementClass(STATEMENT_CON);}
            |IF LPAREN Exp RPAREN   {openScope();
                                     checkIfBool($3->getType());}
                      M Statement   {closeScope();
                                    $$ = new StatementClass(STATEMENT_IF);}
                      IfElse
			|WHILE LPAREN M Exp RPAREN {openScope();
			                          checkIfBool($3->getType());
			                          incWhileCounter();}
			               Statement {closeScope();
			                          $$ = new StatementClass(STATEMENT_WHILE);
			                          decWhileCounter();}
            |LBRACE                  {openScope();}
             Statements RBRACE       {$$ = new StatementClass(STATEMENT_L_STATS_R);
                                      closeScope();}
;
IfElse:     /*epsilon*/ %prec ASSIGN
            |ELSE                    {openScope();}
            N M Statement            {$$ = new StatementClass(STATEMENT_IF_ELSE);
                                      closeScope();}
;

Call:		ID LPAREN ExpList RPAREN  {std::string funcRetType = checkFuncCall($1->getId(), $3->getVecArgsType());
                                      $$ = new CallClass(funcRetType, $1->getId()); }
			|ID LPAREN RPAREN         {std::string funcRetType = checkFuncCall($1->getId());
			                          $$ = new CallClass(funcRetType, $1->getId()); }
;

ExpList:	Exp                     {$$ = new ExpListClass();
                                    $$->addNewArgType($1->getType());}
			|Exp COMMA ExpList      {$$ = new ExpListClass($3->getVecArgsType());
			                        $$->addNewArgType($1->getType());}
;

Type:	    INT                     {$$ = new TypeClass("INT");}
    		|BYTE                   {$$ = new TypeClass("BYTE");}
    		|BOOL                   {$$ = new TypeClass("BOOL");}
;

Exp: 	    ID                      {std::string type = getTypeById($1->getId());
                                    $$ = new ExpClass(EXP_OP_ID, type, std::string(""), $1);}
    		|Call                   {$$ = new ExpClass(EXP_OP_CALL, $1->getType());}
    		|NUM                    {$$ = new ExpClass(EXP_OP_NUM, "INT", $1->getValue());}
    		|NUM B                  {checkIfBValid($1->getValue());
    		                        $$ = new ExpClass(EXP_OP_NUM_B, "BYTE", $1->getValue());}
    		|STRING                 {$$ = new ExpClass(EXP_OP_STRING, "STRING"/*, $1->getValue()*/);}
    		|TRUE                   {$$ = new ExpClass(EXP_OP_TRUE, "BOOL");}
    		|FALSE                  {$$ = new ExpClass(EXP_OP_FALSE, "BOOL"));}
    		|NOT Exp                {checkIfBool($2->getType());
    		                        $$ = new ExpClass(EXP_OP_NOT, "BOOL", std::string(""), $2);} /*the std::string("") is only for compatability with ExpClass*/
    		|Exp OR M Exp           {checkIfBool($1->getType());
    		                        checkIfBool($3->getType());
    		                        $$ = new ExpClass(EXP_OP_OR, "BOOL", std::string(""), $1, $4, $3);} ///why ""?
    		|Exp AND M Exp          {checkIfBool($1->getType());
    		                        checkIfBool($3->getType());
    		                        $$ = new ExpClass(EXP_OP_AND, "BOOL", std::string(""), $1, $4, $3);} ///why ""?
    		|Exp RELOP_EQUAL Exp    {checkIfNumeric($1->getType());
    		                        checkIfNumeric($3->getType());
    		                        $$ = new ExpClass(EXP_OP_EQUAL, "BOOL", std::string(""), $1, $3, $2);} ///why ""?
            |Exp RELOP_GLT Exp      {checkIfNumeric($1->getType());
                                    checkIfNumeric($3->getType());
                                    $$ = new ExpClass(EXP_OP_GLT, "BOOL", std::string(""), $1, $3, $2);} ///why ""?
            |Exp BINOP_ADD Exp      {std::string newType = setRetBinopType($1->getType(),$3->getType());
                                     $$ = new ExpClass(EXP_OP_ADD, newType, std::string(""), $1, $3, $2);} ///why ""?
            |Exp BINOP_MUL Exp      {std::string newType = setRetBinopType($1->getType(),$3->getType());
                                     $$ = new ExpClass(EXP_OP_MUL, newType, std::string(""), $1, $3, $2);} ///why ""?
    		|LPAREN Type RPAREN Exp {checkIfNumeric($2->getType());
    		                        checkIfNumeric($4->getType());
    		                        $$ = new ExpClass(EXP_OP_CAST, $2->getType(), $4->getValue(), $4);}
            |LPAREN Exp RPAREN      {$$ = new ExpClass(EXP_OP_L_EXP_R, $2->getType(), $2->getValue(), $2);}
;

M									{$$ = new M_Class();}

N									{$$ = new N_Class();}
%%

void yyerror(const char* input) {
    output::errorSyn(yylineno);
    exit(0);
}

int main() {
    int retVal = yyparse();
    checkMainExist();
    closeScope();
    return retVal;
}
